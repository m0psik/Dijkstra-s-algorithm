# Теоретическая часть

## Условие задачи
Вы очутились в подземелье, но у вас есть его карта. Постройте оптимальный маршрут движения к выходу. В подземелье могут быть участки, которые можно пройти только в одну сторону.

## Подход к решению задачи
Самым очевидным вариантом представления подземелья будет являться ориентированный граф $`G=(V,E)`$ с неотрицательными весами. Вершинами графа будут являться перекрестки (или комнаты), а ребрами - переходы. Вес ребера показывет длину перехода в некоторых условных единицах. Все веса положительны. Таким образом задача сводится к поиску кратчайшего пути в ориентированном графе.

### Алгоритм Беллмана — Форда
**Алгоритм Беллмана — Форда** — алгоритм поиска кратчайшего пути во взвешенном графе. За время $`O(|E|\cdot |V|)`$ алгоритм находит кратчайшие пути от одной вершины графа до всех остальных. Алгоритм Беллмана — Форда допускает рёбра с отрицательным весом, но не допускает отрицательных циклов.

Пусть — количество путей длины $`k`$ рёбер, заканчивающихся в вершине $`u`$. Тогда $`d[k][u]=\sum_{v: vu \in E}d[k-1][v]`$.

Аналогично посчитаем пути кратчайшей длины. Пусть $`s`$ — стартовая вершина. Тогда
```math
d[k][u]=\min_{v:vu\in E}(d[k−1][v]+\omega (u,v)),
```
где $`\omega (u,v)`$ — вес ребра $`uv`$. При этом  $`d[0][s]=0`$, а $`d[0][u]=+\infty`$.

Если существует кратчайший путь от $`s`$ до $`t`$, то $`\rho(s,t)=\min_{k=0...n-1} d[k][t]`$.

Данный алгоритм можно реализовать методом [динамического программирования](https://ru.wikipedia.org/wiki/Динамическое_программирование).

**Псевдокод**
<pre><code><b>for</b> k=1 <b>to</b> |<I>V</i>|-1:
  <b>for</b> <I>v∈V</i>:
	<b>for</b> <I>(u,v)∈E</I>:
	  d[k][v] = min(d[k][v], d[k-1][u] + ω(u,v))
</code></pre>
После выполнения этого алгоритма элементы $`d_{ij}`$ содержат длины кратчайших путей от $`s`$ до $`i`$, и из всех таких путей следует выбрать самый короткий.

**Замечание:** Отрицательные ребра и циклы отсутствуют по условию задачи. Это значит не нужно проверять граф на наличие отрицательных циклов.

**Оценка сложности**

Cама инициализация занимает $`O(V)`$ времени, каждый из $`|V|−1`$ проходов требует $`O(E)`$ времени. Значит сам алгоритм работает за $`O(|E|\cdot |V|)`$.

### Алгоритм Дейкстры
**Алгоритм Дейкстры** — алгоритм, который находит в ориентированном взвешенном графе $`G=(V,E)`$, вес ребер которого неотрицателен, длины кратчайших  путей из заданной  вершины $`s`$  до всех остальных.

В алгоритме поддерживается множество вершин $`U`$, для которых уже вычислены длины кратчайших путей до них из $`s`$. На каждой итерации основного цикла выбирается вершина $`u\notin U`$, которой на текущий момент соответствует минимальная оценка кратчайшего пути. Вершина $`u`$  добавляется в множество $`U`$ и производится релаксация всех исходящих из неё рёбер.

**Псевдокод**
<pre><code><b>for</b> <I>v∈V</I>:
  d[v] = <i>inf</i>
  used[v] = <i>False</i>
d[s] = 0
<b>for</b> <I>i∈V</I>:
  v = <i>None</i>
  <b>for</b> <I>j∈V</I>:
	<b>if</b> !used[v] <b>and</b> (v <b>is</b> <I>None</I> <b>or</b> d[j] < d[v]):
	  v = j
  <b>if</b> d[v] == <I>inf</i>:
	<b>break</b>
  used[v] = <I>True</I>
  <b>for</b> e, исходящие из v:
	<b>if</b> d[v] + e.len < d[e.to]:
	  d[e.to] = d[v] + e.len
</code></pre>
**Оценка сложности**

В реализации алгоритма присутствует функция выбора вершины с минимальным значением $`d`$ и релаксация по всем рёбрам для данной вершины. Потому асимптотика работы будет зависеть от реализации.

| |Поиск минимума|Релаксация|Общее:
:-:|:-:|:-:|:-:
Массив|$`O(V)`$|$`O(1)`$|$`O(V^{2}+E)`$|
Двоичная куча|$`O(\log V)`$|$`O(\log V)`$|$`O(E\log V)`$
[Фибоначчиева куча](https://ru.wikipedia.org/wiki/Фибоначчиева_куча)|$`O(\log V)`$|$`O(1)`$|$`O(V\log V+E)`$

**Замечание:** При выполнении успешной релаксации нужно удалить из контейнера (кучи) вершину, до которой обновляем расстояние, а затем добавить её же, но с новым расстоянием. В обычных кучах нет операции удаления произвольного элемента. Поэтому можно модифицировать кучу, добавив операцию удаления, или при релаксации не удалять старые пары, в результате чего в куче может находиться одновременно несколько пар расстояние-вершина для одной вершины (с разными расстояниями). Для корректной работы при извлечении из кучи будем проверять расстояние: пары, в которых расстояние отлично от $`d[v]`$  будем игнорировать. При этом асимптотика будет $`O(E\log E)`$ вместо $`O(E\log V)`$.

### Алгоритм Левита
**Алгоритм Левита** — алгоритм, который находит в ориентированном взвешенном графе $`G=(V,E)`$ расстояние от заданной вершины $`s`$ до всех остальных. Позволяет работать с ребрами отрицательного веса при отсутствии отрицательных циклов.

**Алгоритм**

Пусть $`d[i]`$ — текущая длина кратчайшего пути до вершины. Изначально, все элементы $`d`$, кроме $`s`$-го равны бесконечности; $`d[s]=0`$.
Разделим вершины на три множества:
* $`M_0`$ — вершины, расстояние до которых уже вычислено (возможно, не окончательно);
* $`M_1`$ — вершины, расстояние до которых вычисляется. Это множество в свою очередь делится на две очереди:
	* $`M_1^{'}`$ — основная очередь,
	* $`M_1^{''}`$ — срочная очередь;
* $`M_2`$ — вершины, расстояние до которых еще не вычислено.

Изначально все вершины, кроме $`s`$ помещаются в множество $`M_2`$. Вершина $`s`$ помещается в множество $`M_1`$ (в любую из очередей).

**Шаг алгоритма:** выбирается вершина $`u`$ из $`M_1`$. Если очередь $`M_1^{''}`$ не пуста, то вершина берется из нее, иначе из $`M_1^{'}`$. Для каждого ребра $`uv\in E`$ возможны три случая:
* $`v\in M_2`$, то $`v`$ переводится в конец очереди $`M_1^{'}`$. При этом $`d_v\leftarrow d_u+w_{uv}`$ (производится релаксация ребра $`uv`$),
* $`v\in M_1`$, то происходит релаксация ребра $`uv`$,
* $`v\in M_0`$. Если при этом $`d_v>d_u+w_{uv}`$, то происходит релаксация ребра $`uv`$ и вершина $`u`$ помещается в $`M_1^{''}`$; иначе ничего не делаем.

В конце шага помещаем вершину $`u`$ в множество $`M_0`$.

Алгоритм заканчивает работу, когда множество $`M_1`$ становится пустым.

**Оценка сложности**

Рассмотрим полный граф $`K_n`$ с $`n`$ вершинами и такими $`m`$ рёбрами, идущими в лексикографическом порядке:
* для всех вершин $`1<i<j\leq n`$ вес ребра $`(i,j)=j-i-1`$, т. е. количество вершин между $`i`$ и $`j`$; $`w_{i,i+1}=0`$;
* ребро $`(1,n)`$ веса 0;
* для всех вершин $`1<i<n`$ вес ребра $`(i,n)=w_{1,i+1}+i-1`$; от 1 до $`i`$ вершины расстояние равно $`\sum_{k=i-1}^{n-1}k`$.

Ясно, что кратчайший путь до каждой вершины равен $`0`$, но в плохом случае алгоритм при подсчёте вершины $`i`$ будет пересчитывать все вершины до неё (кроме первой). На 1 шаге в очередь положат вершины от 2 до $`n`$, причём вершину 1 из $`M_0`$ больше не достанут. На следующем шаге добавлений не произойдёт, так как вершины больше 2 уже в очереди. На 3 шаге алгоритм улучшит расстояние до вершины 2 на 1 (что видно из веса рёбер (1,2) и (1,3), равных $`\sum_{k=1}^{n-2}k`$ и $`\sum_{k=2}^{n-2}k`$ соответственно), так что её добавят в $`M_1^{''}`$ и обработают на 4 шаге (релаксаций не происходит). На следующем шаге из обычной очереди достанут вершину 4, расстояние до неё, равное $`\sum_{k=3}^{n-2}k`$ на 2  меньше, чем расстояние до 2 и 3 вершин. Их добавят в срочную очередь, но так как $`w_{24}-1=w_{23}`$, то после подсчёта вершины 3 вершину 2 снова добавят в $`M_1^{''}`$. Затем дойдёт очередь до вершины 5, что вызовет релаксацию предыдущих вершин 2,3,4 затем прорелаксируют вершины 2,3 и после вершина 2. Аналогично будут происходить релаксации всех вершин при обработке вершины $`i`$ из очереди $`M_0`$. Таким образом, вершину $`i`$ будут добавлять в срочную очередь $`n−i`$ раз (добавление вершин из очереди $`M_2`$ с номером больше $`i`$) + количество добавлений "старшей" вершины $`i+1`$. Количество добавлений вершины $`i`$ составит $`1+\sum_{k=1}^{n-i}k`$, а сумма всех добавлений примерно составит $`O(nm)`$. При обработке каждой вершины приходится обходить $`n−1`$ ребер, что даёт оценку $`O(n^2m)`$.

## Выбор алгоритма
Для решения задачи был выбран алгоритм Дейкстры. Среди перечисленных алгоритмов поиска кратчайшего пути он обладает минимальной сложностью, равной $`O(V\log V+E)`$, если использовать фибоначчиеву кучу. Но использование фибоначчиевой кучи на практике - не самое лучшее решение из-за большой константы, которая заметна на небольшом объеме данных. К тому же фибоначчиева куча не подразумевает поиск и удаление элемента по ключу, что скажется на дополнительной памяти алгоритма. Поэтому оптимальным решением будет использование двоичной кучи. В таком случае сложность будет равна $`O(E\log V)`$.
Алгоритмы Беллмана — Форда и Левита позволяют работать с ребрами отрицательного веса, но в контексте данной задачи (ребра имеют положительный вес) это достоинство не имеет смысла. Также существуют алгоритмы Флойда и Джонсона, но они находят кратчайшие пути между всеми парами вершин, что не совсем подходит для решения задачи. Кроме того эти алгоритмы ведут себя асимптотически медленнее, чем алгоритм Дейкстры.